<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Soul 网关源码学习(7) - 从依赖的角度理解 Soul 网关 (3) - Zookeeper 数据同步机制"><meta name="keywords" content="soul,网关"><meta name="author" content="David Liu"><meta name="copyright" content="David Liu"><title>Soul 网关源码学习(7) - 从依赖的角度理解 Soul 网关 (3) - Zookeeper 数据同步机制 | David Liu's Blog</title><link rel="shortcut icon" href="/multiple_devices.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7FHY4NYQX5","apiKey":"a36b12831f2af13826a5f6439414dcb2","indexName":"0x12FD16B.github.io","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#soul-admin-%E5%92%8C-soul-bootstrap-%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">1.</span> <span class="toc-text">soul admin 和 soul bootstrap 同步数据的时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-soul-%E7%BD%91%E5%85%B3%E5%A6%82%E4%BD%95%E4%BE%9D%E8%B5%96-zookeeper-%E5%AE%8C%E6%88%90%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5"><span class="toc-number">2.</span> <span class="toc-text">从源码分析 soul 网关如何依赖 zookeeper 完成数据同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">2.1.</span> <span class="toc-text">同步机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#soul-admin-%E4%BE%A7%E7%9A%84%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">soul admin 侧的流程解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#soul-bootstrap-%E4%BE%A7%E7%9A%84%E6%B5%81%E7%A8%8B%E5%89%96%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">soul bootstrap 侧的流程剖析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://hexo-images-1256356315.cos.ap-chengdu.myqcloud.com/avatar.jpg"></div><div class="author-info__name text-center">David Liu</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/0x12FD16B">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">22</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">3</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.jianshu.com/u/645a7ba1b5c2">nuopromise 的简书</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.jianshu.com/u/ce8f1a28ade1">风洛洛的简书</a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">David Liu's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">Soul 网关源码学习(7) - 从依赖的角度理解 Soul 网关 (3) - Zookeeper 数据同步机制</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-21</time><span class="post-meta__separator">|</span><span class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">1.9k</span><span class="post-meta__separator">|</span><span>阅读时长: 7 分钟</span></span></div><div class="article-container" id="post-content"><h2 id="soul-admin-和-soul-bootstrap-同步数据的时机"><a href="#soul-admin-和-soul-bootstrap-同步数据的时机" class="headerlink" title="soul admin 和 soul bootstrap 同步数据的时机"></a>soul admin 和 soul bootstrap 同步数据的时机</h2><p>从昨天的文章中可以看出 soul admin 和 soul bootstrap 之间数据同步的触发的类型主要有两类行为:</p>
<ol>
<li>soul admin 中对 soul bootstrap 运行时数据 (app_auth, plugin, selector, rule 等) 进行了更改，由 soul admin 侧的事件机制触发数据的同步</li>
<li>soul bootstrap 主动触发数据同步，如：WebSocket 客户端和服务端完成了握手行为 (WebSocket 协议应用层的属于) 之后由 soul bootstrap 端主动触发数据的同步</li>
</ol>
<h2 id="从源码分析-soul-网关如何依赖-zookeeper-完成数据同步"><a href="#从源码分析-soul-网关如何依赖-zookeeper-完成数据同步" class="headerlink" title="从源码分析 soul 网关如何依赖 zookeeper 完成数据同步"></a>从源码分析 soul 网关如何依赖 zookeeper 完成数据同步</h2><h3 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h3><p>soul admin 利用 zookeeper 同步数据的原理是使用了 zookeeper 的 watcher 机制, zookeeper 的 watcher 流程如下:</p>
<ul>
<li>客户端向服务端的某个节点路径上注册一个 watcher，客户端同时会在本地 watcher manager 中存储特定的watcher</li>
<li>当发生节点数据或者节点子节点变化时，服务端会通知客户端节点变化信息，客户端收到通知后，会调用 watcher 回调函数</li>
</ul>
<p>在 soul 网关中, soul admin 中集成了 zookeeper 客户端, 在 soul admin 中的数据类型变更数据处理流程中和 zookeeper server 交互; soul bootstrap 模块可配置启用通过 zookeeper 同步数据, 通过 zookeeper 同步数据的功能被集成在了模块<br><code>soul-spring-boot-starter-sync-data-zookeeper</code> 中, 这个模块中有注册 watcher 到 zookeeper 节点路径上的逻辑; 通过上述的流程完成数据的同步。</p>
<h3 id="soul-admin-侧的流程解析"><a href="#soul-admin-侧的流程解析" class="headerlink" title="soul admin 侧的流程解析"></a>soul admin 侧的流程解析</h3><p>soul admin 工程中，在 Spring 事件总线机制中完成 soul 网关数据同步事件监听的类是: <code>org.dromara.soul.admin.listener.DataChangedListener</code>, zookeeper<br>完成数据同步的实现类为: <code>org.dromara.soul.admin.listener.zookeeper.ZookeeperDataChangedListener</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperDataChangedListener</span> <span class="keyword">implements</span> <span class="title">DataChangedListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ZkClient zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZookeeperDataChangedListener</span><span class="params">(<span class="keyword">final</span> ZkClient zkClient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zkClient = zkClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAppAuthChanged</span><span class="params">(<span class="keyword">final</span> List&lt;AppAuthData&gt; changed, <span class="keyword">final</span> DataEventTypeEnum eventType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (AppAuthData data : changed) &#123;</span><br><span class="line">            <span class="keyword">final</span> String appAuthPath = ZkPathConstants.buildAppAuthPath(data.getAppKey()); <span class="comment">// 构造 app auth data 的 zookeeper 数据存储节点的路径信息</span></span><br><span class="line">            <span class="comment">// delete</span></span><br><span class="line">            <span class="keyword">if</span> (eventType == DataEventTypeEnum.DELETE) &#123;</span><br><span class="line">                deleteZkPath(appAuthPath); <span class="comment">// 如果事件的操作类型是删除，则删除 zookeeper 中的节点</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// create or update</span></span><br><span class="line">            upsertZkNode(appAuthPath, data); <span class="comment">// 创建或者更新 zookeeper 中节点的信息 (将数据信息写入到 zookeeper 节点中)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMetaDataChanged</span><span class="params">(<span class="keyword">final</span> List&lt;MetaData&gt; changed, <span class="keyword">final</span> DataEventTypeEnum eventType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (MetaData data : changed) &#123;</span><br><span class="line">            <span class="comment">// 构造 meta data 的 zookeeper 数据存储节点的路径信息</span></span><br><span class="line">            <span class="keyword">final</span> String metaDataPath = ZkPathConstants.buildMetaDataPath(URLEncoder.encode(data.getPath(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">// delete</span></span><br><span class="line">            <span class="keyword">if</span> (eventType == DataEventTypeEnum.DELETE) &#123;</span><br><span class="line">                deleteZkPath(metaDataPath); <span class="comment">// 如果事件的操作类型是删除，则删除 zookeeper 中的节点</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// create or update</span></span><br><span class="line">            upsertZkNode(metaDataPath, data); <span class="comment">// 创建或者更新 zookeeper 中节点的信息 (将数据信息写入到 zookeeper 节点中)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPluginChanged</span><span class="params">(<span class="keyword">final</span> List&lt;PluginData&gt; changed, <span class="keyword">final</span> DataEventTypeEnum eventType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (PluginData data : changed) &#123;</span><br><span class="line">            <span class="comment">// 构造 plugin data 的 zookeeper 数据存储节点的路径信息</span></span><br><span class="line">            <span class="keyword">final</span> String pluginPath = ZkPathConstants.buildPluginPath(data.getName());</span><br><span class="line">            <span class="comment">// delete</span></span><br><span class="line">            <span class="keyword">if</span> (eventType == DataEventTypeEnum.DELETE) &#123;</span><br><span class="line">                <span class="comment">// 如果事件的操作类型是删除，则删除 zookeeper 中的节点</span></span><br><span class="line">                <span class="comment">// selector, rule 数据和 plugin 数据存在关联:</span></span><br><span class="line">                <span class="comment">// selector 节点 zookeeper 路径规则为: /soul/selector/&#123;pluginName&#125;/&#123;selectorId&#125; </span></span><br><span class="line">                <span class="comment">// rule 节点 zookeeper 路径规则为： zoo/soul/rule/&#123;pluginName&#125;/&#123;selectorId&#125;-&#123;ruleId&#125;</span></span><br><span class="line">                <span class="comment">// 所以在操作 zookeeper 中插件路径之后会操作按照规则关联的 selector 路径和 rule 路径</span></span><br><span class="line">                deleteZkPathRecursive(pluginPath);</span><br><span class="line">                <span class="keyword">final</span> String selectorParentPath = ZkPathConstants.buildSelectorParentPath(data.getName());</span><br><span class="line">                deleteZkPathRecursive(selectorParentPath);</span><br><span class="line">                <span class="keyword">final</span> String ruleParentPath = ZkPathConstants.buildRuleParentPath(data.getName());</span><br><span class="line">                deleteZkPathRecursive(ruleParentPath);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//create or update</span></span><br><span class="line">            upsertZkNode(pluginPath, data); <span class="comment">// 创建或者更新 zookeeper 中节点的信息 (将数据信息写入到 zookeeper 节点中)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSelectorChanged</span><span class="params">(<span class="keyword">final</span> List&lt;SelectorData&gt; changed, <span class="keyword">final</span> DataEventTypeEnum eventType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (eventType == DataEventTypeEnum.REFRESH) &#123;</span><br><span class="line">            <span class="comment">// 如果 DataEventType 类型是 REFRESH</span></span><br><span class="line">            <span class="comment">// 获取 selector parent 路径, selector 的路径规则是: /soul/selector/&#123;pluginName&#125;/ </span></span><br><span class="line">            <span class="keyword">final</span> String selectorParentPath = ZkPathConstants.buildSelectorParentPath(changed.get(<span class="number">0</span>).getPluginName());</span><br><span class="line">            <span class="comment">// 删除 selector parent 路径</span></span><br><span class="line">            deleteZkPathRecursive(selectorParentPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (SelectorData data : changed) &#123;</span><br><span class="line">            <span class="comment">// 构建插件选择器数据存储的数据节点路径</span></span><br><span class="line">            <span class="keyword">final</span> String selectorRealPath = ZkPathConstants.buildSelectorRealPath(data.getPluginName(), data.getId());</span><br><span class="line">            <span class="keyword">if</span> (eventType == DataEventTypeEnum.DELETE) &#123;</span><br><span class="line">                <span class="comment">// 如果 DataEventType 类型是 REFRESH, 删除插件选择器数据路径</span></span><br><span class="line">                deleteZkPath(selectorRealPath);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 构建插件选择器所属插件的路径</span></span><br><span class="line">            <span class="keyword">final</span> String selectorParentPath = ZkPathConstants.buildSelectorParentPath(data.getPluginName());</span><br><span class="line">            createZkNode(selectorParentPath);</span><br><span class="line">            <span class="comment">//create or update</span></span><br><span class="line">            upsertZkNode(selectorRealPath, data); <span class="comment">// 创建或者更新 zookeeper 中节点的信息 (将数据信息写入到 zookeeper 节点中)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 处理逻辑和 selector 数据处理方式类似</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRuleChanged</span><span class="params">(<span class="keyword">final</span> List&lt;RuleData&gt; changed, <span class="keyword">final</span> DataEventTypeEnum eventType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (eventType == DataEventTypeEnum.REFRESH) &#123;</span><br><span class="line">            <span class="keyword">final</span> String selectorParentPath = ZkPathConstants.buildRuleParentPath(changed.get(<span class="number">0</span>).getPluginName());</span><br><span class="line">            deleteZkPathRecursive(selectorParentPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (RuleData data : changed) &#123;</span><br><span class="line">            <span class="keyword">final</span> String ruleRealPath = ZkPathConstants.buildRulePath(data.getPluginName(), data.getSelectorId(), data.getId());</span><br><span class="line">            <span class="keyword">if</span> (eventType == DataEventTypeEnum.DELETE) &#123;</span><br><span class="line">                deleteZkPath(ruleRealPath);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> String ruleParentPath = ZkPathConstants.buildRuleParentPath(data.getPluginName());</span><br><span class="line">            createZkNode(ruleParentPath);</span><br><span class="line">            <span class="comment">//create or update</span></span><br><span class="line">            upsertZkNode(ruleRealPath, data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createZkNode</span><span class="params">(<span class="keyword">final</span> String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!zkClient.exists(path)) &#123;</span><br><span class="line">            <span class="comment">// 如果路径不存在，创建持久存储节点</span></span><br><span class="line">            zkClient.createPersistent(path, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create or update zookeeper node.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path node path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data node data </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">upsertZkNode</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!zkClient.exists(path)) &#123;</span><br><span class="line">            <span class="comment">// 如果路径不存在，创建持久存储节点</span></span><br><span class="line">            zkClient.createPersistent(path, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将数据写入 zookeeper 路径中</span></span><br><span class="line">        zkClient.writeData(path, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteZkPath</span><span class="params">(<span class="keyword">final</span> String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (zkClient.exists(path)) &#123;</span><br><span class="line">            <span class="comment">// 如果路径存在，删除路径节点</span></span><br><span class="line">            zkClient.delete(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteZkPathRecursive</span><span class="params">(<span class="keyword">final</span> String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (zkClient.exists(path)) &#123;</span><br><span class="line">            <span class="comment">// 如果路径存在，递归删除路径节点 (将指定路径下的所有节点删除)</span></span><br><span class="line">            zkClient.deleteRecursive(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 zookeeper 中 plugin 节点, selector 节点, rule 节点的路径有一定的关联，关联关系如下:</p>
<table>
<thead>
<tr>
<th>路径类型</th>
<th>路径规则</th>
</tr>
</thead>
<tbody><tr>
<td>AppAuthData</td>
<td>/soul/auth/{appKey}</td>
</tr>
<tr>
<td>MetaData</td>
<td>/soul/meta/{path}</td>
</tr>
<tr>
<td>PluginData</td>
<td>/soul/plugin/{pluginName}</td>
</tr>
<tr>
<td>SelectorData</td>
<td>/soul/selector/{pluginName}/{selectorId}</td>
</tr>
<tr>
<td>RuleData</td>
<td>/soul/rule/{pluginName}/{selectorId}-{ruleId}</td>
</tr>
</tbody></table>
<blockquote>
<p>zookeeper 路径的构造方法在: <code>org.dromara.soul.common.constant.ZkPathConstants</code> 中。</p>
</blockquote>
<p>所以在 <code>ZookeeperDataChangedListener</code> 类的 <code>onPluginChanged</code>,<br><code>onSelectorChanged</code>, <code>onRuleChanged</code> 方法会存在对 zookeeper 路径的复合操作。</p>
<p>soul admin 利用 zookeeper 同步数据到 soul bootstrap 侧依赖的是 soul admin 中监听数据变化事件的处理中的实现类 <code>ZookeeperDataChangedListener</code><br>对 zookeeper 中持久节点的数据节点操作完成不同类型数据的操作来完成不用的 DataEventType 的操作。</p>
<h3 id="soul-bootstrap-侧的流程剖析"><a href="#soul-bootstrap-侧的流程剖析" class="headerlink" title="soul bootstrap 侧的流程剖析"></a>soul bootstrap 侧的流程剖析</h3><p>soul bootstrap 集成模块 <code>soul-spring-boot-starter-sync-data-zookeeper</code> 并且在 Spring 容器启动配置中加入相应的配置来开启 zookeeper 配置。</p>
<blockquote>
<p>配置 zookeeper 数据同步的关键 Configuration</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(ZookeeperSyncDataService.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;soul.sync.zookeeper&quot;, name = &quot;url&quot;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(ZookeeperConfig.class)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperSyncDataConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SyncDataService <span class="title">syncDataService</span><span class="params">(<span class="keyword">final</span> ObjectProvider&lt;ZkClient&gt; zkClient, <span class="keyword">final</span> ObjectProvider&lt;PluginDataSubscriber&gt; pluginSubscriber,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">final</span> ObjectProvider&lt;List&lt;MetaDataSubscriber&gt;&gt; metaSubscribers, <span class="keyword">final</span> ObjectProvider&lt;List&lt;AuthDataSubscriber&gt;&gt; authSubscribers)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;you use zookeeper sync soul data.......&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZookeeperSyncDataService(zkClient.getIfAvailable(), pluginSubscriber.getIfAvailable(),</span><br><span class="line">                metaSubscribers.getIfAvailable(Collections::emptyList), authSubscribers.getIfAvailable(Collections::emptyList));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ZkClient <span class="title">zkClient</span><span class="params">(<span class="keyword">final</span> ZookeeperConfig zookeeperConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZkClient(zookeeperConfig.getUrl(), zookeeperConfig.getSessionTimeout(), zookeeperConfig.getConnectionTimeout());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>配置会被 Spring 容器执行的条件是: classpath 中存在 <code>ZookeeperSyncDataService</code> 类并且 PropertySource 中存在配置 <code>soul.sync.zookeeper.url</code> </li>
<li><code>ZookeeperSyncDataConfiguration</code> 配置类中注册的 <code>SyncDataService</code> 为通过 zookeeper 实现 watcher 机制的关键类, <code>ZookeeperSyncDataConfiguration</code> 的构造函数中完执行了:<ul>
<li>从 zookeeper 读取插件信息, 选择器信息, 规则信息。</li>
<li>注册 watcher 到插件节点路径, 选择器节点路径, 规则节点路径; 当发生节点数据或者节点子节点变化时，服务端会通知客户端节点变化信息，完成数据的同步。</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>soul 利用了 zookeeper 路径节点的 watcher 机制来实现 soul admin 到 soul bootstrap 的数据同步, 结合昨天分析的通过 WebSocket 同步数据, 可以看到一些设计模式的灵活运用, 比如: 观察者模式, 策略模式等, 值得细细学习。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">David Liu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://davidliu.now.sh/2021/01/21/soul_dependency_discoveryII/">https://davidliu.now.sh/2021/01/21/soul_dependency_discoveryII/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://davidliu.now.sh">David Liu's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/soul/">soul</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E5%85%B3/">网关</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-601018c104d1e2b6" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/01/22/soul_dependency_discoveryIII/"><i class="fa fa-chevron-left">  </i><span>Soul 网关源码学习(8) - HTTP 长轮询数据同步机制 (1)</span></a></div><div class="next-post pull-right"><a href="/2021/01/20/soul_dependency_discoveryI/"><span>Soul 网关源码学习(6) - 从依赖的角度理解 Soul 网关 (2) - WebSocket 数据同步机制</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == 'true';
var verify = 'false' == 'true';
var record_ip = 'false' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'BOsCEC5I1p9lJiARGqcwCcA5-gzGzoHsz',
  appKey:'91gkx1rxDiQczTiPWFJ59xLK',
  placeholder:'欢迎留言~',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By David Liu</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">日拱一卒，功不唐捐</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>